import {_isAbsoluteIri} from './_isAbsoluteIri';
import {_isString} from './_isString';
import {_isObject} from './_isObject';
import {_isKeyword} from './_isKeyword';
import {_expandIri} from './_expandIri';
import {JsonLdError} from './JsonLdError';
import {expand} from './expand';
export function _createTermDefinition(activeCtx, localCtx, term, defined) {
      if (term in defined) {
        // term already defined
        if (defined[term]) {
          return;
        }
        // cycle detected
        throw new JsonLdError(
          'Cyclical context definition detected.',
          'jsonld.CyclicalContext',
          {
            code: 'cyclic IRI mapping',
            context: localCtx,
            term: term
          });
      }

      // now defining term
      defined[term] = false;

      if (_isKeyword(term)) {
        throw new JsonLdError(
          'Invalid JSON-LD syntax; keywords cannot be overridden.',
          'jsonld.SyntaxError',
          {
            code: 'keyword redefinition',
            context: localCtx,
            term: term
          });
      }

      if (term === '') {
        throw new JsonLdError(
          'Invalid JSON-LD syntax; a term cannot be an empty string.',
          'jsonld.SyntaxError',
          {
            code: 'invalid term definition',
            context: localCtx
          });
      }

      // remove old mapping
      if (activeCtx.mappings[term]) {
        delete activeCtx.mappings[term];
      }

      // get context term value
      var value = localCtx[term];

      // clear context entry
      if (value === null || (_isObject(value) && value['@id'] === null)) {
        activeCtx.mappings[term] = null;
        defined[term] = true;
        return;
      }

      // convert short-hand value to object w/@id
      if (_isString(value)) {
        value = {
          '@id': value
        };
      }

      if (!_isObject(value)) {
        throw new JsonLdError(
          'Invalid JSON-LD syntax; @context property values must be ' +
          'strings or objects.',
          'jsonld.SyntaxError',
          {
            code: 'invalid term definition',
            context: localCtx
          });
      }

      // create new mapping
      var mapping = activeCtx.mappings[term] = {};
      mapping.reverse = false;

      if ('@reverse' in value) {
        if ('@id' in value) {
          throw new JsonLdError(
            'Invalid JSON-LD syntax; a @reverse term definition must not ' +
            'contain @id.', 'jsonld.SyntaxError',
            {
              code: 'invalid reverse property',
              context: localCtx
            });
        }
        var reverse = value['@reverse'];
        if (!_isString(reverse)) {
          throw new JsonLdError(
            'Invalid JSON-LD syntax; a @context @reverse value must be a string.',
            'jsonld.SyntaxError', {
              code: 'invalid IRI mapping',
              context: localCtx
            });
        }

        // expand and add @id mapping
        var id = _expandIri(
          activeCtx, reverse, {
            vocab: true,
            base: false
          }, localCtx, defined);
        if (!_isAbsoluteIri(id)) {
          throw new JsonLdError(
            'Invalid JSON-LD syntax; a @context @reverse value must be an ' +
            'absolute IRI or a blank node identifier.',
            'jsonld.SyntaxError', {
              code: 'invalid IRI mapping',
              context: localCtx
            });
        }
        mapping['@id'] = id;
        mapping.reverse = true;
      } else if ('@id' in value) {
        var id = value['@id'];
        if (!_isString(id)) {
          throw new JsonLdError(
            'Invalid JSON-LD syntax; a @context @id value must be an array ' +
            'of strings or a string.',
            'jsonld.SyntaxError', {
              code: 'invalid IRI mapping',
              context: localCtx
            });
        }
        if (id !== term) {
          // expand and add @id mapping
          id = _expandIri(
            activeCtx, id, {
              vocab: true,
              base: false
            }, localCtx, defined);
          if (!_isAbsoluteIri(id) && !_isKeyword(id)) {
            throw new JsonLdError(
              'Invalid JSON-LD syntax; a @context @id value must be an ' +
              'absolute IRI, a blank node identifier, or a keyword.',
              'jsonld.SyntaxError',
              {
                code: 'invalid IRI mapping',
                context: localCtx
              });
          }
          mapping['@id'] = id;
        }
      }

      if (!('@id' in mapping)) {
        // see if the term has a prefix
        var colon = term.indexOf(':');
        if (colon !== -1) {
          var prefix = term.substr(0, colon);
          if (prefix in localCtx) {
            // define parent prefix
            _createTermDefinition(activeCtx, localCtx, prefix, defined);
          }

          if (activeCtx.mappings[prefix]) {
            // set @id based on prefix parent
            var suffix = term.substr(colon + 1);
            mapping['@id'] = activeCtx.mappings[prefix]['@id'] + suffix;
          } else {
            // term is an absolute IRI
            mapping['@id'] = term;
          }
        } else {
          // non-IRIs *must* define @ids if @vocab is not available
          if (!('@vocab' in activeCtx)) {
            throw new JsonLdError(
              'Invalid JSON-LD syntax; @context terms must define an @id.',
              'jsonld.SyntaxError',
              {
                code: 'invalid IRI mapping',
                context: localCtx,
                term: term
              });
          }
          // prepend vocab to term
          mapping['@id'] = activeCtx['@vocab'] + term;
        }
      }

      // IRI mapping now defined
      defined[term] = true;

      if ('@type' in value) {
        var type = value['@type'];
        if (!_isString(type)) {
          throw new JsonLdError(
            'Invalid JSON-LD syntax; an @context @type values must be a string.',
            'jsonld.SyntaxError',
            {
              code: 'invalid type mapping',
              context: localCtx
            });
        }

        if (type !== '@id' && type !== '@vocab') {
          // expand @type to full IRI
          type = _expandIri(
            activeCtx, type, {
              vocab: true,
              base: false
            }, localCtx, defined);
          if (!_isAbsoluteIri(type)) {
            throw new JsonLdError(
              'Invalid JSON-LD syntax; an @context @type value must be an ' +
              'absolute IRI.',
              'jsonld.SyntaxError',
              {
                code: 'invalid type mapping',
                context: localCtx
              });
          }
          if (type.indexOf('_:') === 0) {
            throw new JsonLdError(
              'Invalid JSON-LD syntax; an @context @type values must be an IRI, ' +
              'not a blank node identifier.',
              'jsonld.SyntaxError',
              {
                code: 'invalid type mapping',
                context: localCtx
              });
          }
        }

        // add @type to mapping
        mapping['@type'] = type;
      }

      if ('@container' in value) {
        var container = value['@container'];
        if (container !== '@list' && container !== '@set' &&
          container !== '@index' && container !== '@language') {
          throw new JsonLdError(
            'Invalid JSON-LD syntax; @context @container value must be ' +
            'one of the following: @list, @set, @index, or @language.',
            'jsonld.SyntaxError',
            {
              code: 'invalid container mapping',
              context: localCtx
            });
        }
        if (mapping.reverse && container !== '@index' && container !== '@set' &&
          container !== null) {
          throw new JsonLdError(
            'Invalid JSON-LD syntax; @context @container value for a @reverse ' +
            'type definition must be @index or @set.', 'jsonld.SyntaxError',
            {
              code: 'invalid reverse property',
              context: localCtx
            });
        }

        // add @container to mapping
        mapping['@container'] = container;
      }

      if ('@language' in value && !('@type' in value)) {
        var language = value['@language'];
        if (language !== null && !_isString(language)) {
          throw new JsonLdError(
            'Invalid JSON-LD syntax; @context @language value must be ' +
            'a string or null.', 'jsonld.SyntaxError',
            {
              code: 'invalid language mapping',
              context: localCtx
            });
        }

        // add @language to mapping
        if (language !== null) {
          language = language.toLowerCase();
        }
        mapping['@language'] = language;
      }

      // disallow aliasing @context and @preserve
      var id = mapping['@id'];
      if (id === '@context' || id === '@preserve') {
        throw new JsonLdError(
          'Invalid JSON-LD syntax; @context and @preserve cannot be aliased.',
          'jsonld.SyntaxError', {
            code: 'invalid keyword alias',
            context: localCtx
          });
      }
    }
