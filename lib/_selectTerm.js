import {_isSubjectReference} from './_isSubjectReference';
import {_compactIri} from './_compactIri';
import {compact} from './compact';
export function _selectTerm(
      activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue) {
      if (typeOrLanguageValue === null) {
        typeOrLanguageValue = '@null';
      }

      // preferences for the value of @type or @language
      var prefs = [];

      // determine prefs for @id based on whether or not value compacts to a term
      if ((typeOrLanguageValue === '@id' || typeOrLanguageValue === '@reverse') &&
        _isSubjectReference(value)) {
        // prefer @reverse first
        if (typeOrLanguageValue === '@reverse') {
          prefs.push('@reverse');
        }
        // try to compact value to a term
        var term = _compactIri(activeCtx, value['@id'], null, {
          vocab: true
        });
        if (term in activeCtx.mappings &&
          activeCtx.mappings[term] &&
          activeCtx.mappings[term]['@id'] === value['@id']) {
          // prefer @vocab
          prefs.push.apply(prefs, ['@vocab', '@id']);
        } else {
          // prefer @id
          prefs.push.apply(prefs, ['@id', '@vocab']);
        }
      } else {
        prefs.push(typeOrLanguageValue);
      }
      prefs.push('@none');

      var containerMap = activeCtx.inverse[iri];
      for (var ci = 0; ci < containers.length; ++ci) {
        // if container not available in the map, continue
        var container = containers[ci];
        if (!(container in containerMap)) {
          continue;
        }

        var typeOrLanguageValueMap = containerMap[container][typeOrLanguage];
        for (var pi = 0; pi < prefs.length; ++pi) {
          // if type/language option not available in the map, continue
          var pref = prefs[pi];
          if (!(pref in typeOrLanguageValueMap)) {
            continue;
          }

          // select term
          return typeOrLanguageValueMap[pref];
        }
      }

      return null;
    }
